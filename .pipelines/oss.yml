parameters:
- name: pipelineWorkspace
  type: string
- name: retinaOSSRepoName #not sure if really need but put for now, YEAH NEED BUT pass this variable for githuboss in 'main'
  type: string
- name: retinaEnterpriseRepoName
  type: string


stages:
  - stage: build
    displayName: Linux Buildx
    variables:
      APP_INSIGHTS_ID: "99c62452-029a-4341-bc0f-e689b7473601" 
    jobs:
      - job: prepare
        displayName: Setup
        pool:
          type: linux
        variables:
          ob_outputDirectory: $(Build.SourcesDirectory)/out
          OB_build_container: true
          ob_git_checkout: true
        steps:
          # - checkout: self
          #这里的问题是我不知道在哪里所以我想遵循amilcar的原则
          - checkout: ${{ parameters.retinaOSSRepoName }}

            fetchTags: true
            #build number is predefined in the pipeline runtime?
            #tag是否要保持大小写一致
          - script: |
              BUILD_NUMBER=$(Build.BuildNumber)            
              # 获取版本号
              if [ "$(Build.Reason)" = "Schedule" ]; then
                echo "Pipeline triggered by schedule. Using 'latest' as tag."
                TAG="latest"
              else
                # 检查当前 commit 是否有 tag
                if [[ -z $(git tag --points-at HEAD) ]]; then
                  echo "No tag found on the current commit. Using commit hash as version."
                  TAG=$(git rev-parse --short HEAD)
                else
                  echo "Tag found on the current commit. Using it as version."
                  TAG=$(git tag --points-at HEAD)
                fi
              fi
              # 输出流水线变量，因为最后的目的是传递那个变量吧，vso是为了ADO通讯用
              echo "Tag version is: $TAG"
              echo "##vso[task.setvariable variable=TAG_VERSION;isOutput=true]$TAG"

            name: setVariables #你看上面有一个task.setvariable，这个是为了传递变量，所以这个名字是为了传递变量的，不然你pass不过去
            displayName: "Set environmental variables"
            condition: always()

          - checkout: ${{ parameters.retinaenterpriseRepoName }}
            fetchTags: true
            displayName: "Checkout Retina Enterprise"
          - script: |
              echo "Contents of $(Build.SourcesDirectory):"
              ls $(Build.SourcesDirectory)
            name: listContents
            displayName: "List Contents"
            condition: always()


          - task: CopyFiles@2
            displayName: Prepare sources for docker build
            inputs:
              SourceFolder: $(Build.SourcesDirectory)/${{ parameters.retinaOSSRepoName }}
              TargetFolder: '$(Build.SourcesDirectory)/out/${{ parameters.retinaOSSRepoName }}'
          - task: CopyFiles@2
            displayName: Enterprise for docker build
            inputs:
              SourceFolder: $(Build.SourcesDirectory)/${{ parameters.retinaEnterpriseRepoName }}
              TargetFolder: '$(Build.SourcesDirectory)/out/${{ parameters.retinaEnterpriseRepoName }}'          



      # - job: agentLinuxAmd64ImageBuild
      #   displayName: Agent Linux amd64 Image Build
      #   dependsOn: prepare  #换工作
      #   condition: succeeded()
      #   pool:
      #     type: docker #这里有待考证到底是怎么设置的，我只是抄的，但是我不知道怎么搞的其实
      #     os: linux
      #   variables:
      #     TAG_VERSION: $[ dependencies.prepare.outputs['setVariables.TAG_VERSION'] ]
      #     #这里这个可能要改，因为我是固定的，而且之前没有set过这个，但是enterprise是根据之前prepare的id给出的才能，我这个应该在pipeline variable里set
      #     APP_INSIGHTS_ID: $(APP_INSIGHTS_ID)   #感觉直接这个就可以了 $(APP_INSIGHTS_ID)
      #     ob_git_checkout: true  #OneBranch Pipelines doesn't clone the repository in the Docker job by default. To access the source code, you need to set the ob_git_checkout job variable:
      #   steps:
      #     - task: DownloadPipelineArtifact@2
      #       displayName: 'Download Artifacts'
      #       inputs:
      #         targetPath: $(Build.SourcesDirectory)/dst/drop_build_prepare #也要挨着替换吧，所有的prepare都要注意一下,我其实不知道这个dst是怎么来的，这个路径为什么，但是就先这样
      #         artifact: drop_build_prepare
      #     - task: onebranch.pipeline.imagebuildinfo@1
      #       inputs:
      #         buildkit: 1  #stand for buildx
      #         dockerFileRelPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }}/controller/Dockerfile 
      #         arguments: "--platform linux/amd64 --build-arg APP_INSIGHTS_ID=$(APP_INSIGHTS_ID) --build-arg VERSION=$(TAG_VERSION) --build-arg GOOS=linux --build-arg GOARCH=amd64 --build-arg OS_VERSION=ltsc2019 --build-arg HUBBLE_VERSION=v1.16.5 --target=agent"
      #         dockerFileContextPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }} #不确定对不对，和之前那个realpath有关但是
      #         repositoryName: retina-oss-agent  #这个是你的image名字一部分，然后也是你自己取得
      #         registry: ghcr.io/microsoft
      #         compress: true
      #         saveImageToPath: retina-agent-$(TAG_VERSION)-linux-amd64.tar.gz  #每次保存一个image之后，用的是tar file，然后这是命名tar file的东西
      #         enable_network: true
      #         enable_service_tree_acr_path: false
      #         build_tag: $(TAG_VERSION)-linux-amd64   #每个image的命名规则是 cr/repo/name:tag  所以这就是版本号吧
      #         saveMetadataToPath: image-metadata-retina-agent-$(TAG_VERSION).json  #有待考证

      # - job: agentInitLinuxAmd64ImageBuild
      #   displayName: Agent Init Linux amd64 Image Build
      #   dependsOn: prepare
      #   condition: succeeded()
      #   pool:
      #     type: docker
      #     os: linux
      #   variables:
      #     TAG_VERSION: $[ dependencies.prepare.outputs['setVariables.TAG_VERSION'] ]
      #     APP_INSIGHTS_ID: $(APP_INSIGHTS_ID)
      #     ob_git_checkout: true
      #   steps:
      #     - task: DownloadPipelineArtifact@2
      #       displayName: 'Download Artifacts'
      #       inputs:
      #         targetPath: $(Build.SourcesDirectory)/dst/drop_build_prepare
      #         artifact: drop_build_prepare
      #     - task: onebranch.pipeline.imagebuildinfo@1
      #       inputs:
      #         buildkit: 1  #stand for buildx
      #         dockerFileRelPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }}/controller/Dockerfile
      #         arguments: "--platform linux/amd64 --build-arg APP_INSIGHTS_ID=$(APP_INSIGHTS_ID) --build-arg VERSION=$(TAG_VERSION) --build-arg GOOS=linux --build-arg GOARCH=amd64 --build-arg OS_VERSION=ltsc2019 --build-arg HUBBLE_VERSION=v1.16.5 --target=init"
      #         dockerFileContextPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }} # need test
      #         repositoryName: retina-oss-init  #这个是你的image名字一部分，然后也是你自己取得
      #         registry: ghcr.io/microsoft
      #         compress: true
      #         saveImageToPath: retina-init-$(TAG_VERSION)-linux-amd64.tar.gz  #每次保存一个image之后，用的是tar file，然后这是命名tar file的东西
      #         enable_network: true
      #         enable_service_tree_acr_path: false
      #         build_tag: $(TAG_VERSION)-linux-amd64   #每个image的命名规则是 cr/repo/name:tag  所以这就是版本号吧
      #         saveMetadataToPath: image-metadata-retina-init-$(TAG_VERSION).json  #有待考证


      # - job: operatorLinuxAmd64ImageBuild
      #   displayName: Operator Linux amd64 Image Build
      #   dependsOn: prepare
      #   condition: succeeded()
      #   pool:
      #     type: docker
      #     os: linux
      #   variables:
      #     TAG_VERSION: $[ dependencies.prepare.outputs['setVariables.TAG_VERSION'] ]
      #     APP_INSIGHTS_ID: $(APP_INSIGHTS_ID)
      #     ob_git_checkout: true
      #   steps:
      #     - task: DownloadPipelineArtifact@2
      #       displayName: 'Download Artifacts'
      #       inputs:
      #         targetPath: $(Build.SourcesDirectory)/dst/drop_build_prepare
      #         artifact: drop_build_prepare
      #     - task: onebranch.pipeline.imagebuildinfo@1
      #       inputs:
      #         buildkit: 1  #stand for buildx
      #         dockerFileRelPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }}/operator/Dockerfile
      #         arguments: "--platform linux/amd64 --build-arg APP_INSIGHTS_ID=$(APP_INSIGHTS_ID) --build-arg VERSION=$(TAG_VERSION) --build-arg GOOS=linux --build-arg GOARCH=amd64 --build-arg OS_VERSION=ltsc2019 --build-arg HUBBLE_VERSION=v1.16.5"
      #         dockerFileContextPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }}
      #         repositoryName: retina-oss-operator  #这个是你的image名字一部分，然后也是你自己取得
      #         registry: ghcr.io/microsoft
      #         compress: true
      #         saveImageToPath: retina-operator-$(TAG_VERSION)-linux-amd64.tar.gz  #每次保存一个image之后，用的是tar file，然后这是命名tar file的东西
      #         enable_network: true
      #         enable_service_tree_acr_path: false
      #         build_tag: $(TAG_VERSION)-linux-amd64   #每个image的命名规则是 cr/repo/name:tag  所以这就是版本号吧
      #         saveMetadataToPath: image-metadata-retina-operator-$(TAG_VERSION).json  #有待考证


      # - job: agentLinuxArm64ImageBuild
      #   displayName: Agent Linux arm64 Image Build
      #   dependsOn: prepare  #换工作
      #   condition: succeeded()
      #   pool:
      #     type: docker #这里有待考证到底是怎么设置的，我只是抄的，但是我不知道怎么搞的其实
      #     os: linux
      #   variables:
      #     TAG_VERSION: $[ dependencies.prepare.outputs['setVariables.TAG_VERSION'] ]
      #     #这里这个可能要改，因为我是固定的，而且之前没有set过这个，但是enterprise是根据之前prepare的id给出的才能，我这个应该在pipeline variable里set
      #     APP_INSIGHTS_ID: $(APP_INSIGHTS_ID)   #感觉直接这个就可以了 $(APP_INSIGHTS_ID)
      #     ob_git_checkout: true  #OneBranch Pipelines doesn't clone the repository in the Docker job by default. To access the source code, you need to set the ob_git_checkout job variable:
      #     # This variable is needed to enable QEMU for ARM64 builds. https://eng.ms/docs/products/onebranch/build/containerbasedworkflow/dockerimagesandacr/buildarm64containers
      #     # ${{  if eq(parameters.arch, 'arm64')  }}:
      #     ob_enable_qemu: true
      #   steps:
      #     - task: DownloadPipelineArtifact@2
      #       displayName: 'Download Artifacts'
      #       inputs:
      #         targetPath: $(Build.SourcesDirectory)/dst/drop_build_prepare #也要挨着替换吧，所有的prepare都要注意一下,我其实不知道这个dst是怎么来的，这个路径为什么，但是就先这样
      #         artifact: drop_build_prepare
      #     - task: onebranch.pipeline.imagebuildinfo@1
      #       inputs:
      #         buildkit: 1  #stand for buildx
      #         dockerFileRelPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }}/controller/Dockerfile 
      #         arguments: "--platform linux/arm64 --build-arg APP_INSIGHTS_ID=$(APP_INSIGHTS_ID) --build-arg VERSION=$(TAG_VERSION) --build-arg GOOS=linux --build-arg GOARCH=arm64 --build-arg OS_VERSION=ltsc2019 --build-arg HUBBLE_VERSION=v1.16.5 --target=agent"
      #         dockerFileContextPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }} #不确定对不对，和之前那个realpath有关但是
      #         repositoryName: retina-oss-agent  #这个是你的image名字一部分，然后也是你自己取得
      #         registry: ghcr.io/microsoft
      #         compress: true
      #         saveImageToPath: retina-agent-$(TAG_VERSION)-linux-arm64.tar.gz  #每次保存一个image之后，用的是tar file，然后这是命名tar file的东西
      #         enable_network: true
      #         enable_service_tree_acr_path: false
      #         build_tag: $(TAG_VERSION)-linux-arm64   #每个image的命名规则是 cr/repo/name:tag  所以这就是版本号吧
      #         saveMetadataToPath: image-metadata-retina-agent-$(TAG_VERSION).json  #有待考证


      # - job: agentInitLinuxArm64ImageBuild
      #   displayName: Agent Init Linux arm64 Image Build
      #   dependsOn: prepare
      #   condition: succeeded()
      #   pool:
      #     type: docker
      #     os: linux
      #   variables:
      #     TAG_VERSION: $[ dependencies.prepare.outputs['setVariables.TAG_VERSION'] ]
      #     APP_INSIGHTS_ID: $(APP_INSIGHTS_ID)
      #     ob_git_checkout: true
      #     ob_enable_qemu: true
      #   steps:
      #     - task: DownloadPipelineArtifact@2
      #       displayName: 'Download Artifacts'
      #       inputs:
      #         targetPath: $(Build.SourcesDirectory)/dst/drop_build_prepare
      #         artifact: drop_build_prepare
      #     - task: onebranch.pipeline.imagebuildinfo@1
      #       inputs:
      #         buildkit: 1  #stand for buildx
      #         dockerFileRelPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }}/controller/Dockerfile
      #         arguments: "--platform linux/arm64 --build-arg APP_INSIGHTS_ID=$(APP_INSIGHTS_ID) --build-arg VERSION=$(TAG_VERSION) --build-arg GOOS=linux --build-arg GOARCH=arm64 --build-arg OS_VERSION=ltsc2019 --build-arg HUBBLE_VERSION=v1.16.5 --target=init"
      #         dockerFileContextPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }} # need test
      #         repositoryName: retina-oss-init  #这个是你的image名字一部分，然后也是你自己取得
      #         registry: ghcr.io/microsoft
      #         compress: true
      #         saveImageToPath: retina-init-$(TAG_VERSION)-linux-arm64.tar.gz  #每次保存一个image之后，用的是tar file，然后这是命名tar file的东西
      #         enable_network: true
      #         enable_service_tree_acr_path: false
      #         build_tag: $(TAG_VERSION)-linux-arm64   #每个image的命名规则是 cr/repo/name:tag  所以这就是版本号吧
      #         saveMetadataToPath: image-metadata-retina-init-$(TAG_VERSION).json  #有待考证

      # - job: operatorLinuxArm64ImageBuild
      #   displayName: Operator Linux arm64 Image Build
      #   dependsOn: prepare
      #   condition: succeeded()
      #   pool:
      #     type: docker
      #     os: linux
      #   variables:
      #     TAG_VERSION: $[ dependencies.prepare.outputs['setVariables.TAG_VERSION'] ]
      #     APP_INSIGHTS_ID: $(APP_INSIGHTS_ID)
      #     ob_git_checkout: true
      #     ob_enable_qemu: true
      #   steps:
      #     - task: DownloadPipelineArtifact@2
      #       displayName: 'Download Artifacts'
      #       inputs:
      #         targetPath: $(Build.SourcesDirectory)/dst/drop_build_prepare
      #         artifact: drop_build_prepare
      #     - task: onebranch.pipeline.imagebuildinfo@1
      #       inputs:
      #         buildkit: 1  #stand for buildx
      #         dockerFileRelPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }}/operator/Dockerfile
      #         arguments: "--platform linux/arm64 --build-arg APP_INSIGHTS_ID=$(APP_INSIGHTS_ID) --build-arg VERSION=$(TAG_VERSION) --build-arg GOOS=linux --build-arg GOARCH=arm64 --build-arg OS_VERSION=ltsc2019 --build-arg HUBBLE_VERSION=v1.16.5"
      #         dockerFileContextPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }} # need test
      #         repositoryName: retina-oss-operator  #这个是你的image名字一部分，然后也是你自己取得
      #         registry: ghcr.io/microsoft
      #         compress: true
      #         saveImageToPath: retina-operator-$(TAG_VERSION)-linux-arm64.tar.gz  #每次保存一个image之后，用的是tar file，然后这是命名tar file的东西
      #         enable_network: true
      #         enable_service_tree_acr_path: false
      #         build_tag: $(TAG_VERSION)-linux-arm64   #每个image的命名规则是 cr/repo/name:tag  所以这就是版本号吧
      #         saveMetadataToPath: image-metadata-retina-operator-$(TAG_VERSION).json  #有待考证

      # - job: shellLinuxAmd64ImageBuild
      #   displayName: Build Retina Amd64 Shell Images 
      #   dependsOn: prepare
      #   condition: succeeded()
      #   pool:
      #     type: docker
      #     os: linux
      #   variables:
      #     TAG_VERSION: $[ dependencies.prepare.outputs['setVariables.TAG_VERSION'] ]
      #     APP_INSIGHTS_ID: $(APP_INSIGHTS_ID)
      #     ob_git_checkout: true
      #   steps:
      #     - task: DownloadPipelineArtifact@2
      #       displayName: 'Download Artifacts'
      #       inputs:
      #         targetPath: $(Build.SourcesDirectory)/dst/drop_build_prepare
      #         artifact: drop_build_prepare
      #     - task: onebranch.pipeline.imagebuildinfo@1
      #       inputs:
      #         buildkit: 1  #stand for buildx
      #         dockerFileRelPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }}/shell/Dockerfile
      #         arguments: "--platform linux/amd64 --build-arg APP_INSIGHTS_ID=$(APP_INSIGHTS_ID) --build-arg VERSION=$(TAG_VERSION) --build-arg GOOS=linux --build-arg GOARCH=arm64 --build-arg OS_VERSION=ltsc2019 --build-arg HUBBLE_VERSION=v1.16.5"
      #         dockerFileContextPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }} # need test
      #         repositoryName: retina-oss-shell  #这个是你的image名字一部分，然后也是你自己取得
      #         registry: ghcr.io/microsoft
      #         compress: true
      #         saveImageToPath: retina-shell-$(TAG_VERSION)-linux-amd64.tar.gz  #每次保存一个image之后，用的是tar file，然后这是命名tar file的东西
      #         enable_network: true
      #         enable_service_tree_acr_path: false
      #         build_tag: $(TAG_VERSION)-linux-amd64   #每个image的命名规则是 cr/repo/name:tag  所以这就是版本号吧
      #         saveMetadataToPath: image-metadata-retina-shell-$(TAG_VERSION).json  #有待考证


      # - job: shellLinuxArm64ImageBuild
      #   displayName: Build Retina Amd64 Shell Images 
      #   dependsOn: prepare
      #   condition: succeeded()
      #   pool:
      #     type: docker
      #     os: linux
      #   variables:
      #     TAG_VERSION: $[ dependencies.prepare.outputs['setVariables.TAG_VERSION'] ]
      #     APP_INSIGHTS_ID: $(APP_INSIGHTS_ID)
      #     ob_git_checkout: true
      #     ob_enable_qemu: true
      #   steps:
      #     - task: DownloadPipelineArtifact@2
      #       displayName: 'Download Artifacts'
      #       inputs:
      #         targetPath: $(Build.SourcesDirectory)/dst/drop_build_prepare
      #         artifact: drop_build_prepare
      #     - task: onebranch.pipeline.imagebuildinfo@1
      #       inputs:
      #         buildkit: 1  #stand for buildx
      #         dockerFileRelPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }}/shell/Dockerfile
      #         arguments: "--platform linux/arm64 --build-arg APP_INSIGHTS_ID=$(APP_INSIGHTS_ID) --build-arg VERSION=$(TAG_VERSION) --build-arg GOOS=linux --build-arg GOARCH=arm64 --build-arg OS_VERSION=ltsc2019 --build-arg HUBBLE_VERSION=v1.16.5"
      #         dockerFileContextPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }} # need test
      #         repositoryName: retina-oss-shell  #这个是你的image名字一部分，然后也是你自己取得
      #         registry: ghcr.io/microsoft
      #         compress: true
      #         saveImageToPath: retina-shell-$(TAG_VERSION)-linux-arm64.tar.gz  #每次保存一个image之后，用的是tar file，然后这是命名tar file的东西
      #         enable_network: true
      #         enable_service_tree_acr_path: false
      #         build_tag: $(TAG_VERSION)-linux-arm64   #每个image的命名规则是 cr/repo/name:tag  所以这就是版本号吧
      #         saveMetadataToPath: image-metadata-retina-shell-$(TAG_VERSION).json  #有待考证

      # - job: KubectlLinuxAmd64ImageBuild
      #   displayName: Build kubectl Retina Amd64 Images 
      #   dependsOn: prepare
      #   condition: succeeded()
      #   pool:
      #     type: docker
      #     os: linux
      #   variables:
      #     TAG_VERSION: $[ dependencies.prepare.outputs['setVariables.TAG_VERSION'] ]
      #     APP_INSIGHTS_ID: $(APP_INSIGHTS_ID)
      #     ob_git_checkout: true
      #   steps:
      #     - task: DownloadPipelineArtifact@2
      #       displayName: 'Download Artifacts'
      #       inputs:
      #         targetPath: $(Build.SourcesDirectory)/dst/drop_build_prepare
      #         artifact: drop_build_prepare
      #     - task: onebranch.pipeline.imagebuildinfo@1
      #       inputs:
      #         buildkit: 1  #stand for buildx
      #         dockerFileRelPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }}/cli/Dockerfile
      #         arguments: "--platform linux/amd64 --build-arg APP_INSIGHTS_ID=$(APP_INSIGHTS_ID) --build-arg VERSION=$(TAG_VERSION) --build-arg GOOS=linux --build-arg GOARCH=arm64 --build-arg OS_VERSION=ltsc2019 --build-arg HUBBLE_VERSION=v1.16.5"
      #         dockerFileContextPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }} # need test
      #         repositoryName: kubectl-retina  #这个是你的image名字一部分，然后也是你自己取得
      #         registry: ghcr.io/microsoft
      #         compress: true
      #         saveImageToPath: kubectl-retina-$(TAG_VERSION)-linux-amd64.tar.gz  #每次保存一个image之后，用的是tar file，然后这是命名tar file的东西
      #         enable_network: true
      #         enable_service_tree_acr_path: false
      #         build_tag: $(TAG_VERSION)-linux-amd64   #每个image的命名规则是 cr/repo/name:tag  所以这就是版本号吧
      #         saveMetadataToPath: image-metadata-kubectl-retina-$(TAG_VERSION).json  #有待考证

      # - job: KubectlLinuxArm64ImageBuild
      #   displayName: Build kubectl Retina Arm64 Images 
      #   dependsOn: prepare
      #   condition: succeeded()
      #   pool:
      #     type: docker
      #     os: linux
      #   variables:
      #     TAG_VERSION: $[ dependencies.prepare.outputs['setVariables.TAG_VERSION'] ]
      #     APP_INSIGHTS_ID: $(APP_INSIGHTS_ID)
      #     ob_git_checkout: true
      #     ob_enable_qemu: true
      #   steps:
      #     - task: DownloadPipelineArtifact@2
      #       displayName: 'Download Artifacts'
      #       inputs:
      #         targetPath: $(Build.SourcesDirectory)/dst/drop_build_prepare
      #         artifact: drop_build_prepare
      #     - task: onebranch.pipeline.imagebuildinfo@1
      #       inputs:
      #         buildkit: 1  #stand for buildx
      #         dockerFileRelPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }}/cli/Dockerfile
      #         arguments: "--platform linux/arm64 --build-arg APP_INSIGHTS_ID=$(APP_INSIGHTS_ID) --build-arg VERSION=$(TAG_VERSION) --build-arg GOOS=linux --build-arg GOARCH=arm64 --build-arg OS_VERSION=ltsc2019 --build-arg HUBBLE_VERSION=v1.16.5"
      #         dockerFileContextPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }} # need test
      #         repositoryName: kubectl-retina  #这个是你的image名字一部分，然后也是你自己取得
      #         registry: ghcr.io/microsoft
      #         compress: true
      #         saveImageToPath: kubectl-retina-$(TAG_VERSION)-linux-arm64.tar.gz  #每次保存一个image之后，用的是tar file，然后这是命名tar file的东西
      #         enable_network: true
      #         enable_service_tree_acr_path: false
      #         build_tag: $(TAG_VERSION)-linux-arm64   #每个image的命名规则是 cr/repo/name:tag  所以这就是版本号吧
      #         saveMetadataToPath: image-metadata-kubectl-retina-$(TAG_VERSION).json  #有待考证


      - job: builderForWindowsNative
        displayName: Builder for Windows Navite Image Build
        dependsOn: prepare
        condition: succeeded()
        pool:
          type: docker
          os: windows
          hostVersion: 1ESWindows2022
        variables:
          # WINDOWS_VERSION: $[ dependencies.prepare.outputs['setVariables.WINDOWS_VERSION'] ]
          WindowsContainerImage: 'onebranch.azurecr.io/windows/ltsc2022/vse2022:latest' # https://aka.ms/obpipelines/containers
          # WINDOWS_VERSION: $[ dependencies.prepare.outputs['setVariables.TAG_VERSION'] ]
          WINDOWS_VERSION: alpha
          APP_INSIGHTS_ID: $(APP_INSIGHTS_ID)
          # ONEBRANCH_AME_ACR_LOGIN: onebranch.azurecr.io, cdpxdd590928-4e04-48cb-9d3d-ee06c5f0e17f00.azurecr.io  # https://eng.ms/docs/products/onebranch/build/containerbasedworkflow/dockerimagesandacr/isolatedacr
          ob_git_checkout: true
        steps:
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Artifacts'
            inputs:
              targetPath: $(Build.SourcesDirectory)/dst/drop_build_prepare
              artifact: drop_build_prepare

          - task: onebranch.pipeline.containercontrol@1
            displayName: "Login to source ACR"
            inputs:
                command: login
                acr_name: cdpxdd590928-4e04-48cb-9d3d-ee06c5f0e17f00.azurecr.io   #https://eng.ms/docs/products/onebranch/build/containerbasedworkflow/dockerimagesandacr/isolatedacr
                tenant: MSFT

          - task: onebranch.pipeline.imagebuildinfo@1
            inputs:
              dockerFileRelPath: drop_build_prepare/${{ parameters.retinaEnterpriseRepoName }}/windows/docker/Dockerfile.windows-cgo
              arguments: "--build-arg VERSION=$(WINDOWS_VERSION) --target=builder"
              dockerFileContextPath: drop_build_prepare/${{ parameters.retinaEnterpriseRepoName }}
              repositoryName: retina-builder #your name it yourself whatever
              compress: false #using the default value for late use
              saveImageToPath: retina-builder-windows-amd64-$(WINDOWS_VERSION).tar
              enable_network: true
              build_tag: windows-amd64-$(WINDOWS_VERSION)
              #push to isolated acr
              registry: cdpxdd590928-4e04-48cb-9d3d-ee06c5f0e17f00.azurecr.io
              enable_isolated_acr_push: true
              enable_service_tree_acr_path: false


                # Step 3: 构建 Retina Agent 镜像，直接使用 .tar 文件路径
          - task: onebranch.pipeline.imagebuildinfo@1
            inputs:
              dockerFileRelPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }}/controller/Dockerfile.windows-native
              arguments: "--build-arg BUILDER_IMAGE=cdpxdd590928-4e04-48cb-9d3d-ee06c5f0e17f00.azurecr.io/Buddy/retina-builder --build-arg VERSION=$(WINDOWS_VERSION) --target=final --build-arg APP_INSIGHTS_ID=$(APP_INSIGHTS_ID)"
              # arguments: "--build-arg BUILDER_IMAGE=$(Build.SourcesDirectory)/retina-builder-windows-amd64-$(WINDOWS_VERSION).tar --build-arg VERSION=$(WINDOWS_VERSION) --target=final --build-arg APP_INSIGHTS_ID=$(APP_INSIGHTS_ID)"
              dockerFileContextPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }}
              repositoryName: retina-agent-win
              registry: ghcr.io/microsoft
              enable_network: true
              enable_service_tree_acr_path: false
              build_tag: windows-amd64-$(WINDOWS_VERSION)


          # - task: onebranch.pipeline.containercontrol@1
          #   displayName: "Load Builder Image"
          #   inputs:
          #     command: load
          #     imagePath: $(Build.SourcesDirectory)/dst/drop_build_prepare/retina-builder-windows-amd64-$(WINDOWS_VERSION).tar.gz
          # - task: PowerShell@2
          #   displayName: "Extract and Load Builder Image"
          #   inputs:
          #     targetType: 'inline'
          #     script: |
          #       $tarGzPath = "$(Build.SourcesDirectory)/dst/drop_build_prepare/retina-builder-windows-amd64-$(WINDOWS_VERSION).tar.gz"
          #       $tarPath = "$(Build.SourcesDirectory)/dst/drop_build_prepare/retina-builder-windows-amd64-$(WINDOWS_VERSION).tar"
          #       Write-Host "Extracting $tarGzPath to $tarPath"
          #       tar -xzf $tarGzPath -C "$(Build.SourcesDirectory)/dst/drop_build_prepare"
          #       Write-Host "Loading Docker image from $tarPath"
          #       docker load -i $tarPath



          # - task: onebranch.pipeline.imagebuildinfo@1
          #   inputs:
          #     dockerFileRelPath: drop_build_prepare/${{ parameters.retinaOSSRepoName }}/controller/Dockerfile.windows-native
          #     arguments: "--platform windows/amd64  --build-arg BUILDER_IMAGE=$fullBuilderImageName --build-arg VERSION=$(WINDOWS_VERSION) --build-arg APP_INSIGHTS_ID=$(APP_INSIGHTS_ID) --target final"
          #     dockerFileContextPath: drop_build_prepare/${{ parameters.retinaEnterpriseRepoName }}
          #     repositoryName: retina-builder
          #     registry: ghcr.io/microsoft
          #     compress: true
          #     saveImageToPath: retina-builder-windows-amd64-$(WINDOWS_VERSION).tar.gz
          #     enable_network: true
          #     enable_service_tree_acr_path: false
          #     build_tag: windows-amd64-$(WINDOWS_VERSION)
              # enable_acr_push: true
              # endpoint: $(ACR_SERVICE_CONNECTION)

